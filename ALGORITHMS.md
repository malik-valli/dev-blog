## “Big-O? Is this an order from McDonald's?”: Is it useful to solve algorithmic problems?

![Algorithms](https://user-images.githubusercontent.com/81878781/180293364-f17cc641-459b-42d2-8ffc-e77fd7a1f7d1.png)

A couple of weeks ago I finished reading the book “Grok Algorithms” by Aditya Bhargava. It is written very clearly and moderately informative (they do not dump out a huge pile of theory). It is worth saying that before her I was digging into algorithms and data structures. And although the book was intended by the author as an introduction to algorithms, I would say that it can be enough for a significant number of developers in most areas of development. But! this is if you read it all and try it with your own hands. And at the end, the author writes words of parting words, the topics of which can be studied further.

The answer to the question of the post is yes, it is useful. It is useful for any developer to know data structures, because they work, in fact, with the same data! And, of course, the ways they are processed. But this does not mean that you need to dig into hundreds of books, articles and courses from the name of a prestigious university on algorithms and data structures (unless, of course, you are a data engineer).
I started studying these topics quite late, but I should have done it earlier.

Is this often required in practice? - rarely. Basically, it comes in handy only at an interview :D (in the future, maybe the practice of interviews will change).

If anyone is interested in running through the topics, here is my list of what I studied:

Data structures:
- Array
- Static and dynamic arrays
    - Heterogeneous array
- Stack (stack, LIFO)
- Queue (queue, FIFO)
- Linked list (linked list)
- Dictionary, hash table (map, hash table, dictionary)
- Graph (graph)
- Tree (tree)
- Set (set)

Search algorithms:
- Binary search
- Breadth-first search
- Dijkstra's algorithm
    - Bellman-Ford algorithm

Sorting algorithms:
- Selection sort
- Bubble sort
    - Shaker sorting (cocktail sort)
- Quick sort (quicksort)
- Comb sorting
- Sorting by inserts
- Merge sorting
- Pyramid sorting

Conditional execution speeds, in descending order:
- O(log n) - logarithmic complexity (binary search)
- O(n) - linear (simple search)
- O(n * log n). Efficient sorting algorithms (quick sort)
- O(n2). Slow sorting algorithms (sorting by choice)
- O(n!) - factorial. Very slow algorithms (the traveling salesman problem)

Maybe someone will need it for notes.
Good luck!
