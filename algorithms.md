# “Big-O? Is this an order from McDonald's?”: Is it useful to solve algorithmic problems?

![Algorithms](https://user-images.githubusercontent.com/81878781/180293364-f17cc641-459b-42d2-8ffc-e77fd7a1f7d1.png)

A couple of weeks ago I finished reading the book *“Grokking Algorithms”* by Aditya Bhargava. It is written very clearly and moderately meaningful (they do not dump out a huge pile of theory). It is worth saying that before it I was digging into algorithms and data structures. And although the book was intended by the author as an introduction to algorithms, I would say that it can be enough for a significant number of developers in most areas of development. But! this is if you read it all and try it with <ins>your own hands</ins>. And at the end, the author writes words of parting words, the topics of which can be studied further.

The answer to the question of the post is ***yes***, it is useful. It is useful for any developer to know data structures, because they work in fact with the same data! And of course the ways of processing them. But this does not mean that you need to dig into hundreds of books, articles and courses from the ~~name of a prestigious university~~ on algorithms and data structures (unless, of course, you are a data engineer).
I started studying these topics quite late, but I should have done it earlier.

Is this often required in practice? - rarely. Basically, it comes in handy only at an interview :D (in the future, maybe the practice of interviews will change).

If anyone is interested in running through the topics, here is my list of what I studied:

### Data structures:
- Array
- Static and dynamic arrays. Heterogenous array
- Stack (LIFO)
- Queue (FIFO)
- Linked list
- Dictionary /hash table /map
- Graph
- Tree
- Set

### Search algorithms:
- Binary search
- Breadth-first search
- Dijkstra's algorithm
    - Bellman-Ford algorithm

### Sorting algorithms:
- Selection sort
- Bubble sort
    - Cocktail sort
- Quick sort
- Sorting with a comb
- Sorting by inserts
- Merge sorting
- Pyramid sorting

### Conditional execution speeds, in descending order:
- O(log n) - logarithmic complexity (binary search)
- O(n) - linear (simple search)
- O(n * log n). Efficient sorting algorithms (quick sort)
- O(n2). Slow sorting algorithms (selection sort)
- O(n!) - factorial. Very slow algorithms (the traveling salesman problem)

Maybe someone will need it for notes.
Good luck!

### Leave comments in [Telegram](https://t.me/sinblog/12)
